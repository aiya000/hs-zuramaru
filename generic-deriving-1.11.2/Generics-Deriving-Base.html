<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Generics.Deriving.Base</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Generics-Deriving-Base.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Generics.Deriving.Base.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">generic-deriving-1.11.2: Generic programming library for generalised deriving.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Generics.Deriving.Base</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a><ul><li><a href="#g:2">Representing datatypes</a></li><li><a href="#g:3">Derived and fundamental representation types</a><ul><li><a href="#g:4">Individual fields of constructors: <code>K1</code></a></li><li><a href="#g:5">Meta information: <code>M1</code></a></li><li><a href="#g:6">Additional generic representation type constructors</a><ul><li><a href="#g:7">Empty datatypes: <code>V1</code></a></li><li><a href="#g:8">Constructors without fields: <code>U1</code></a></li></ul></li><li><a href="#g:9">Representation of types with many constructors or many fields</a></li></ul></li><li><a href="#g:10">Defining datatype-generic functions</a><ul><li><a href="#g:11">Definition of the generic representation types</a></li><li><a href="#g:12">Generic instances</a></li><li><a href="#g:13">The wrapper and generic default</a></li><li><a href="#g:14">Omitting generic instances</a></li></ul></li><li><a href="#g:15">Generic constructor classes</a><ul><li><a href="#g:16">The <code>Generic1</code> class</a></li><li><a href="#g:17">Representation of <code>* -&gt; *</code> types</a></li><li><a href="#g:18">Representation of unlifted types</a></li></ul></li></ul></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="../base-4.9.1.0/GHC-Generics.html">GHC.Generics</a></li></ul></div><div id="interface"><h1 id="g:1">Introduction</h1><div class="doc"><p>Datatype-generic functions are are based on the idea of converting values of
 a datatype <code>T</code> into corresponding values of a (nearly) isomorphic type <code><code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> T</code>.
 The type <code><code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> T</code> is
 built from a limited set of type constructors, all provided by this module. A
 datatype-generic function is then an overloaded function with instances
 for most of these type constructors, together with a wrapper that performs
 the mapping between <code>T</code> and <code><code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> T</code>. By using this technique, we merely need
 a few generic instances in order to implement functionality that works for any
 representable type.</p><p>Representable types are collected in the <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> class, which defines the
 associated type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> as well as conversion functions <code><a href="../base-4.9.1.0/GHC-Generics.html#v:from">from</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#v:to">to</a></code>.
 Typically, you will not define <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> instances by hand, but have the compiler
 derive them for you.</p></div><h2 id="g:2">Representing datatypes</h2><div class="doc"><p>The key to defining your own datatype-generic functions is to understand how to
 represent datatypes using the given set of type constructors.</p><p>Let us look at an example first:</p><pre>data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code>
</pre><p>The above declaration (which requires the language pragma <code>DeriveGeneric</code>)
 causes the following representation to be generated:</p><pre>class <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> (Tree a) where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> (Tree a) =
    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1Tree
      (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0Tree
         (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code>Par0</code> a))
       <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code>
       <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_1Tree
         (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> (Tree a))
          <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>
          <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> (Tree a))))
  ...
</pre><p><em>Hint:</em> You can obtain information about the code being generated from GHC by passing
 the <code>-ddump-deriv</code> flag. In GHCi, you can expand a type family such as <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> using
 the <code>:kind!</code> command.</p></div><h2 id="g:3">Derived and fundamental representation types</h2><div class="doc"><p>There are many datatype-generic functions that do not distinguish between positions that
 are parameters or positions that are recursive calls. There are also many datatype-generic
 functions that do not care about the names of datatypes and constructors at all. To keep
 the number of cases to consider in generic functions in such a situation to a minimum,
 it turns out that many of the type constructors introduced above are actually synonyms,
 defining them to be variants of a smaller set of constructors.</p></div><h3 id="g:4">Individual fields of constructors: <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code></h3><div class="doc"><p>The type constructors <code>Par0</code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> are variants of <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>:</p><pre>type <code>Par0</code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> <code>P</code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:R">R</a></code>
</pre><p>Here, <code>P</code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:R">R</a></code> are type-level proxies again that do not have any associated values.</p></div><h3 id="g:5">Meta information: <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code></h3><div class="doc"><p>The type constructors <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> are all variants of <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>:</p><pre>type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S">S</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C">C</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D">D</a></code>
</pre><p>The types <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S">S</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C">C</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:R">R</a></code> are once again type-level proxies, just used to create
 several variants of <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>.</p></div><h3 id="g:6">Additional generic representation type constructors</h3><div class="doc"><p>Next to <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> there are a few more type constructors that occur
 in the representations of other datatypes.</p></div><h4 id="g:7">Empty datatypes: <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code></h4><div class="doc"><p>For empty datatypes, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> is used as a representation. For example,</p><pre>data Empty deriving <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code>
</pre><p>yields</p><pre>instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> Empty where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> Empty = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1Empty <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code>
</pre></div><h4 id="g:8">Constructors without fields: <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code></h4><div class="doc"><p>If a constructor has no arguments, then <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> is used as its representation. For example
 the representation of <code><a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></code> is</p><pre>instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> Bool where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> Bool =
    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1Bool
      (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0Bool <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_1Bool <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code>)
</pre></div><h3 id="g:9">Representation of types with many constructors or many fields</h3><div class="doc"><p>As <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> are just binary operators, one might ask what happens if the
 datatype has more than two constructors, or a constructor with more than two
 fields. The answer is simple: the operators are used several times, to combine
 all the constructors and fields as needed. However, users /should not rely on
 a specific nesting strategy/ for <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> being used. The compiler is
 free to choose any nesting it prefers. (In practice, the current implementation
 tries to produce a more or less balanced nesting, so that the traversal of the
 structure of the datatype from the root to a particular component can be performed
 in logarithmic rather than linear time.)</p></div><h2 id="g:10">Defining datatype-generic functions</h2><div class="doc"><p>A datatype-generic function comprises two parts:</p><ol><li><em>Generic instances</em> for the function, implementing it for most of the representation
       type constructors introduced above.</li><li>A <em>wrapper</em> that for any datatype that is in <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code>, performs the conversion
       between the original value and its <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code>-based representation and then invokes the
       generic instances.</li></ol><p>As an example, let us look at a function <code>encode</code> that produces a naive, but lossless
 bit encoding of values of various datatypes. So we are aiming to define a function</p><pre>encode :: <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> a =&gt; a -&gt; [Bool]
</pre><p>where we use <code><a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></code> as our datatype for bits.</p><p>For part 1, we define a class <code>Encode'</code>. Perhaps surprisingly, this class is parameterized
 over a type constructor <code>f</code> of kind <code>* -&gt; *</code>. This is a technicality: all the representation
 type constructors operate with kind <code>* -&gt; *</code> as base kind. But the type argument is never
 being used. This may be changed at some point in the future. The class has a single method,
 and we use the type we want our final function to have, but we replace the occurrences of
 the generic type argument <code>a</code> with <code>f p</code> (where the <code>p</code> is any argument; it will not be used).</p><pre>class Encode' f where
  encode' :: f p -&gt; [Bool]</pre><p>With the goal in mind to make <code>encode</code> work on <code>Tree</code> and other datatypes, we now define
 instances for the representation type constructors <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>, and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>.</p></div><h3 id="g:11">Definition of the generic representation types</h3><div class="doc"><p>In order to be able to do this, we need to know the actual definitions of these types:</p><pre>data    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code>        p                       -- lifted version of Empty
data    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code>        p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code>                  -- lifted version of ()
data    (<code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code>) f g p = <code><a href="../base-4.9.1.0/GHC-Generics.html#v:L1">L1</a></code> (f p) | <code><a href="../base-4.9.1.0/GHC-Generics.html#v:R1">R1</a></code> (g p) -- lifted version of <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code>
data    (<code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>) f g p = (f p) <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> (g p)     -- lifted version of (,)
newtype <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>    i c p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> { <code><a href="../base-4.9.1.0/GHC-Generics.html#v:unK1">unK1</a></code> :: c }    -- a container for a c
newtype <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>  i t f p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> { <code><a href="../base-4.9.1.0/GHC-Generics.html#v:unM1">unM1</a></code> :: f p }  -- a wrapper
</pre><p>So, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> is just the unit type, <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> is just a binary choice like <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code>,
 <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> is a binary pair like the pair constructor <code>(,)</code>, and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> is a value
 of a specific type <code>c</code>, and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> wraps a value of the generic type argument,
 which in the lifted world is an <code>f p</code> (where we do not care about <code>p</code>).</p></div><h3 id="g:12">Generic instances</h3><div class="doc"><p>The instance for <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> is slightly awkward (but also rarely used):</p><pre>instance Encode' <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> where
  encode' x = undefined
</pre><p>There are no values of type <code>V1 p</code> to pass (except undefined), so this is
 actually impossible. One can ask why it is useful to define an instance for
 <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> at all in this case? Well, an empty type can be used as an argument to
 a non-empty type, and you might still want to encode the resulting type.
 As a somewhat contrived example, consider <code>[Empty]</code>, which is not an empty
 type, but contains just the empty list. The <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> instance ensures that we
 can call the generic function on such types.</p><p>There is exactly one value of type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code>, so encoding it requires no
 knowledge, and we can use zero bits:</p><pre>instance Encode' <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> where
  encode' <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> = []
</pre><p>In the case for <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code>, we produce <code><a href="../base-4.9.1.0/Data-Bool.html#v:False">False</a></code> or <code><a href="../base-4.9.1.0/Data-Bool.html#v:True">True</a></code> depending on whether
 the constructor of the value provided is located on the left or on the right:</p><pre>instance (Encode' f, Encode' g) =&gt; Encode' (f <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> g) where
  encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#v:L1">L1</a></code> x) = False : encode' x
  encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#v:R1">R1</a></code> x) = True  : encode' x
</pre><p>In the case for <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>, we append the encodings of the two subcomponents:</p><pre>instance (Encode' f, Encode' g) =&gt; Encode' (f <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> g) where
  encode' (x <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> y) = encode' x ++ encode' y
</pre><p>The case for <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> is rather interesting. Here, we call the final function
 <code>encode</code> that we yet have to define, recursively. We will use another type
 class <code>Encode</code> for that function:</p><pre>instance (Encode c) =&gt; Encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> i c) where
  encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> x) = encode x
</pre><p>Note how <code>Par0</code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> both being mapped to <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> allows us to define
 a uniform instance here.</p><p>Similarly, we can define a uniform instance for <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>, because we completely
 disregard all meta-information:</p><pre>instance (Encode' f) =&gt; Encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> i t f) where
  encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> x) = encode' x
</pre><p>Unlike in <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>, the instance for <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> refers to <code>encode'</code>, not <code>encode</code>.</p></div><h3 id="g:13">The wrapper and generic default</h3><div class="doc"><p>We now define class <code>Encode</code> for the actual <code>encode</code> function:</p><pre>class Encode a where
  encode :: a -&gt; [Bool]
  default encode :: (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> a) =&gt; a -&gt; [Bool]
  encode x = encode' (<code><a href="../base-4.9.1.0/GHC-Generics.html#v:from">from</a></code> x)
</pre><p>The incoming <code>x</code> is converted using <code><a href="../base-4.9.1.0/GHC-Generics.html#v:from">from</a></code>, then we dispatch to the
 generic instances using <code>encode'</code>. We use this as a default definition
 for <code>encode</code>. We need the 'default encode' signature because ordinary
 Haskell default methods must not introduce additional class constraints,
 but our generic default does.</p><p>Defining a particular instance is now as simple as saying</p><pre>instance (Encode a) =&gt; Encode (Tree a)
</pre></div><h3 id="g:14">Omitting generic instances</h3><div class="doc"><p>It is not always required to provide instances for all the generic
 representation types, but omitting instances restricts the set of
 datatypes the functions will work for:</p><ul><li>If no <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> instance is given, the function may still work for
      empty datatypes or datatypes that have a single constructor,
      but will fail on datatypes with more than one constructor.</li><li>If no <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> instance is given, the function may still work for
      datatypes where each constructor has just zero or one field,
      in particular for enumeration types.</li><li>If no <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> instance is given, the function may still work for
      enumeration types, where no constructor has any fields.</li><li>If no <code><a href="../base-4.9.1.0/GHC-Generics.html#t:V1">V1</a></code> instance is given, the function may still work for
      any datatype that is not empty.</li><li>If no <code><a href="../base-4.9.1.0/GHC-Generics.html#t:U1">U1</a></code> instance is given, the function may still work for
      any datatype where each constructor has at least one field.</li></ul><p>An <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code> instance is always required (but it can just ignore the
 meta-information, as is the case for <code>encode</code> above).</p></div><h2 id="g:15">Generic constructor classes</h2><div class="doc"><p>Datatype-generic functions as defined above work for a large class
 of datatypes, including parameterized datatypes. (We have used <code>Tree</code>
 as our example above, which is of kind <code>* -&gt; *</code>.) However, the
 <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> class ranges over types of kind <code>*</code>, and therefore, the
 resulting generic functions (such as <code>encode</code>) must be parameterized
 by a generic type argument of kind <code>*</code>.</p><p>What if we want to define generic classes that range over type
 constructors (such as <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code>, <code><a href="../base-4.9.1.0/Data-Traversable.html#t:Traversable">Traversable</a></code>, or <code><a href="../base-4.9.1.0/Data-Foldable.html#t:Foldable">Foldable</a></code>)?</p></div><h3 id="g:16">The <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code> class</h3><div class="doc"><p>Like <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code>, there is a class <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code> that defines a
 representation <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> and conversion functions <code><a href="../base-4.9.1.0/GHC-Generics.html#v:from1">from1</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#v:to1">to1</a></code>,
 only that <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code> ranges over types of kind <code>* -&gt; *</code>.
 The <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code> class is also derivable.</p><p>The representation <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> is ever so slightly different from <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code>.
 Let us look at <code>Tree</code> as an example again:</p><pre>data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code>
</pre><p>The above declaration causes the following representation to be generated:</p><p>class <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code> Tree where
   type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> Tree =
     <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1Tree
       (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0Tree
          (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code>)
        <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code>
        <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_1Tree
          (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> Tree)
           <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>
           <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> Tree)))
   ...</p><p>The representation reuses <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code>, <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> (and thereby <code><a href="../base-4.9.1.0/GHC-Generics.html#t:M1">M1</a></code>) as well
 as <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-43-:">:+:</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code> from <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code>. (This reusability is the reason that we
 carry around the dummy type argument for kind-<code>*</code>-types, but there are
 already enough different names involved without duplicating each of
 these.)</p><p>What's different is that we now use <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code> to refer to the parameter
 (and that parameter, which used to be <code>a</code>), is not mentioned explicitly
 by name anywhere; and we use <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> to refer to a recursive use of <code>Tree a</code>.</p></div><h3 id="g:17">Representation of <code>* -&gt; *</code> types</h3><div class="doc"><p>Unlike <code>Par0</code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code>, the <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> type constructors do not
 map to <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code>. They are defined directly, as follows:</p><pre>newtype <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code>   p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code> { <code><a href="../base-4.9.1.0/GHC-Generics.html#v:unPar1">unPar1</a></code> ::   p } -- gives access to parameter p
newtype <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> f p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> { <code><a href="../base-4.9.1.0/GHC-Generics.html#v:unRec1">unRec1</a></code> :: f p } -- a wrapper
</pre><p>In <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code>, the parameter <code>p</code> is used for the first time, whereas <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> simply
 wraps an application of <code>f</code> to <code>p</code>.</p><p>Note that <code><a href="../base-4.9.1.0/GHC-Generics.html#t:K1">K1</a></code> (in the guise of <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code>) can still occur in a <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> representation,
 namely when the datatype has a field that does not mention the parameter.</p><p>The declaration</p><pre>data WithInt a = WithInt Int a
  deriving <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic1">Generic1</a></code>
</pre><p>yields</p><pre>class <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> WithInt where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> WithInt =
    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1WithInt
      (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0WithInt
        (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> Int)
         <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>
         <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code>))
</pre><p>If the parameter <code>a</code> appears underneath a composition of other type constructors,
 then the representation involves composition, too:</p><pre>data Rose a = Fork a [Rose a]
</pre><p>yields</p><pre>class <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> Rose where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep1">Rep1</a></code> Rose =
    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1Rose
      (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0Rose
        (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Par1">Par1</a></code>
         <code><a href="../base-4.9.1.0/GHC-Generics.html#t::-42-:">:*:</a></code>
         <code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> ([] <code><a href="../base-4.9.1.0/GHC-Generics.html#t::.:">:.:</a></code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec1">Rec1</a></code> Rose)
</pre><p>where</p><pre>newtype (<code><a href="../base-4.9.1.0/GHC-Generics.html#t::.:">:.:</a></code>) f g p = <code><a href="../base-4.9.1.0/GHC-Generics.html#v:Comp1">Comp1</a></code> { <code><a href="../base-4.9.1.0/GHC-Generics.html#v:unComp1">unComp1</a></code> :: f (g p) }
</pre></div><h3 id="g:18">Representation of unlifted types</h3><div class="doc"><p>If one were to attempt to derive a Generic instance for a datatype with an
 unlifted argument (for example, <code>Int#</code>), one might expect the occurrence of
 the <code>Int#</code> argument to be marked with <code><code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> <code>Int#</code></code>. This won't work,
 though, since <code>Int#</code> is of kind <code>#</code> and <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code> expects a type of kind <code>*</code>.
 In fact, polymorphism over unlifted types is disallowed completely.</p><p>One solution would be to represent an occurrence of <code>Int#</code> with 'Rec0 Int'
 instead. With this approach, however, the programmer has no way of knowing
 whether the <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code> is actually an <code>Int#</code> in disguise.</p><p>Instead of reusing <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rec0">Rec0</a></code>, a separate data family <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> is used to mark
 occurrences of common unlifted types:</p><pre>data family URec a p

data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> (<code>Ptr</code> ()) p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UAddr">UAddr</a></code>   { <code>uAddr#</code>   :: <code>Addr#</code>   }
data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code>     p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UChar">UChar</a></code>   { <code>uChar#</code>   :: <code>Char#</code>   }
data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Prelude.html#t:Double">Double</a></code>   p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UDouble">UDouble</a></code> { <code>uDouble#</code> :: <code>Double#</code> }
data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code>      p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UFloat">UFloat</a></code>  { <code>uFloat#</code>  :: <code>Float#</code>  }
data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Prelude.html#t:Float">Float</a></code>    p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UInt">UInt</a></code>    { <code>uInt#</code>    :: <code>Int#</code>    }
data instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Word.html#t:Word">Word</a></code>     p = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UWord">UWord</a></code>   { <code>uWord#</code>   :: <code>Word#</code>   }
</pre><p>Several type synonyms are provided for convenience:</p><pre>type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UAddr">UAddr</a></code>   = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> (<code>Ptr</code> ())
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UChar">UChar</a></code>   = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UDouble">UDouble</a></code> = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Prelude.html#t:Double">Double</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UFloat">UFloat</a></code>  = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Prelude.html#t:Float">Float</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UInt">UInt</a></code>    = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code>
type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UWord">UWord</a></code>   = <code><a href="../base-4.9.1.0/GHC-Generics.html#t:URec">URec</a></code> <code><a href="../base-4.9.1.0/Data-Word.html#t:Word">Word</a></code>
</pre><p>The declaration</p><pre>data IntHash = IntHash Int#
  deriving <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code>
</pre><p>yields</p><pre>instance <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Generic">Generic</a></code> IntHash where
  type <code><a href="../base-4.9.1.0/GHC-Generics.html#t:Rep">Rep</a></code> IntHash =
    <code><a href="../base-4.9.1.0/GHC-Generics.html#t:D1">D1</a></code> D1IntHash
      (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:C1">C1</a></code> C1_0IntHash
        (<code><a href="../base-4.9.1.0/GHC-Generics.html#t:S1">S1</a></code> <code>NoSelector</code> <code><a href="../base-4.9.1.0/GHC-Generics.html#t:UInt">UInt</a></code>))
</pre><p>Currently, only the six unlifted types listed above are generated, but this
 may be extended to encompass more unlifted types in the future.</p></div><div class="top"><p class="src">module <a href="../base-4.9.1.0/GHC-Generics.html">GHC.Generics</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>